#!/usr/bin/env python3

import os
from scripts.utils import get_out_dir

SCRIPT_DIR = 'scripts'

MODELS = ['clock', 'noClock']
RUNS = [f'{i+1:04d}' for i in range(config['cellcoal']['no_rep'])]
TREES = [i for i,j in config['tree'].items() if j['run']]

scheduler = config.get('scheduler', None)
tree_weights = config.get('poisson', {}).get('tree_weights', [0])
if isinstance(tree_weights, (int, float)):
    tree_weights = [tree_weights]
tree_weights = list(set([0 if i < 1 else i for i in tree_weights]))

# if isinstance(config.get('mrbayes', {}).get('ngen', None), (int, float)):
#     config['mrbayes']['ngen'] = [config['mrbayes']['ngen']]
out_dir, filter_dir = get_out_dir(config)
base_dir = os.path.join(out_dir, filter_dir)

def get_final_files(wildcards):
    files = []
    # if config['cellcoal'].get('output', {}).get('true_haplotypes', False):
    #     files += [os.path.join(out_dir, 'true_haplotypes_dir', f'true_vcf.{i}')
    #         for i in RUNS]

    for tree in TREES:
        if config.get('paup', {}).get('run', False):
            files.append(os.path.join(base_dir, f'paup_dir_{tree}',
                'paup.summary.tsv'))

        if config.get('poisson', {}).get('tree', False) or \
                config.get('poisson', {}).get('run', False):
            for tree_weight in tree_weights:
                files.append(os.path.join(base_dir,
                    f'poissonTree_{tree_weight}_{tree}',
                    'poissonTree.summary.tsv'))

        if config.get('sieve', {}).get('run', False):
            files.append(os.path.join(out_dir, 'sieve_dir',
                f'sieve_{tree}.summary.tsv'))
        if config.get('mrbayes', {}).get('run', False):
            files.append(os.path.join(base_dir, f'mrbayes_dir_{tree}',
                'mrbayes.summary.tsv'))

    if config.get('poisson', {}).get('dispersion', False) or \
                config.get('poisson', {}).get('run', False):
        files.append(os.path.join(base_dir, 'poissonDisp.summary.tsv'))

    return files


rule all:
    input:
        os.path.join(base_dir, 'final_summary.tsv'),


rule merge_summary_files:
    input:
        get_final_files
    output:
        os.path.join(base_dir, 'final_summary.tsv')
    envmodules:
        'pandas/1.0.1-python-3.7.7',
    resources:
        mem_mb = 4096,
        runtime = 20,
    script:
        f'{SCRIPT_DIR}/merge_summaries.py'


# ------------------------------- CELLCOAL -------------------------------------

rule create_cellcoal_config:
    output:
        cellcoal = 'cellcoal_parameters',
        snakemake ='snakemake_config.yaml',
    params:
        template = config['cellcoal'] \
            .get('parameter', 'cellcoal_parameters.template'),
        out_dir = out_dir,
    resources:
        mem_mb = 1024
    script:
        f'{SCRIPT_DIR}/get_cellcoal_config.py'


rule run_cellcoal:
    input:
        cellcoal = 'cellcoal_parameters',
        snakemake ='snakemake_config.yaml',
    output:
        expand(os.path.join(out_dir, 'vcf_dir', 'vcf.{run}'), run=RUNS),
        expand(os.path.join(out_dir, 'trees_dir', 'trees.{run}'), run=RUNS),
    resources:
        mem_mb = 32768 * (1 + config['cellcoal'].get('no_rep', 10) // 500),
        runtime = 180,
    params:
        exe = config['cellcoal']['exe'],
    shell:
        'mkdir -p {out_dir} && '
        '{params.exe} -F{input} > {out_dir}/log 2> sims && '
        'cat sims >> {out_dir}/log && ' #rm sims && '
        'mv {input.cellcoal} {out_dir}/config_cellcoal && '
        'mv {input.snakemake} {out_dir}/config_snakemake'


# -------------------------- DATA POSTPROCESSING -------------------------------

rule generate_overview_file:
    input:
        expand(os.path.join(out_dir, 'vcf_dir', 'vcf.{run}'), run=RUNS)
    output:
        stats = os.path.join(base_dir, 'data_overview.tsv'),
        ADO = os.path.join(base_dir, 'ADO_overview.tsv')
    params:
        no_cells = config['cellcoal']['model']['no_cells'],
    run:
        cols = ['run', 'muts_cells', 'muts_outgrp', 'muts_false',
            'sides', 'TP-sides', 'FP_sides', 'TN_sides', 'FN_sides', 'MS_sides']
        with open(output.stats, 'w') as f:
            f.write('\t'.join(cols) + '\n')

        cells = '\t'.join([f'tumcell{i+1:0>4}' for i in range(params.no_cells)] \
            + ['healthycell'])
        with open(output.ADO, 'w') as f:
            f.write('run\t' + cells + '\n')


rule postprocess_vcf:
    input:
        vcf = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}'),
        stats = ancient(
            os.path.join(base_dir, 'data_overview.tsv')),
        ADO = ancient(os.path.join(base_dir, 'ADO_overview.tsv'))
    output:
        os.path.join(base_dir, 'vcf_dir', 'vcf.{run}.final.gz')
    envmodules:
        'numpy/1.18.1-python-3.7.7',
    resources:
        runtime = 30,
    params:
        dp = config.get('SNP_filter', {}).get('depth', 1),
        gq = config.get('SNP_filter', {}).get('quality', 0),
        s_dp = config.get('SNP_filter', {}).get('singleton_depth', None),
        s_alt = config.get('SNP_filter', {}).get('singleton_alts', None),
        singletons = config.get('SNP_filter', {}).get('singletons', False),
    script:
        f'{SCRIPT_DIR}/postprocess_vcf.py'


# rule get_true_GT:
#     input:
#         os.path.join(out_dir, 'vcf_dir', 'vcf.{run}')
#     output:
#         os.path.join(out_dir, 'true_haplotypes_dir', 'true_vcf.{run}')
#     resources:
#         mem_mb = 4096
#     script:
#         f'{SCRIPT_DIR}/convert_haplotype_to_vcf.py'


def get_nex_input(wildcards):
    if config.get('monovar', {}).get('run', False):
        vcf_in_file = 'vcf.{wildcards.run}.monovar.final' \
            .format(wildcards=wildcards)
    else:
        vcf_in_file = 'vcf.{wildcards.run}.final.gz'.format(wildcards=wildcards)

    vcf = os.path.join(base_dir, 'vcf_dir', vcf_in_file)

    if wildcards.tree == 'cellphy':
        tree = os.path.join(base_dir, 'cellphy_dir',
            'cellphy_tree.{wildcards.run}.Mapped.raxml.mutationMapTree' \
                .format(wildcards=wildcards))
    elif wildcards.tree == 'scite':
        tree = os.path.join(base_dir, 'scite_dir',
            'scite_tree.{wildcards.run}_ml0.newick'.format(wildcards=wildcards))
    else:
        tree = os.path.join(out_dir, 'trees_dir', 'trees.{wildcards.run}' \
            .format(wildcards=wildcards))

    return {'tree': tree, 'vcf': vcf}


rule vcf_to_nex:
    input:
        unpack(get_nex_input)
    output:
        temp(expand(os.path.join(base_dir, 'nxs_dir_{{tree}}',
            'nxs.{{run}}.{{steps}}.{model}'), model=MODELS))
    resources:
        mem_mb = 1024,
        runtime = 30,
    params:
        ss = config.get('mrbayes', {}).get('ss', False),
        paup_exe = config.get('paup', {}).get('exe', 'paup'),
        exclude = config.get('poisson', {}).get('exclude', ''),
        include = config.get('poisson', {}).get('include', ''),
    script:
        f'{SCRIPT_DIR}/convert_vcf_to_nexus.py'


# ------------------------------- MONOVAR --------------------------------------

rule vcf_to_mpileup:
    input:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}')
    output:
        pileup = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.mpileup'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleNames.txt'),
        s_types = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleTypes.txt')
    resources:
        mem_mb = 4096
    script:
        f'{SCRIPT_DIR}/convert_vcf_to_pileup.py'


rule run_monovar:
    input:
        pileup = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.mpileup'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleNames.txt')
    output:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.monovar.vcf')
    threads: 2
    resources:
        mem_mb = 4096 if scheduler == 'lsf' else 2 * 4096
    conda: 'envs/monovar.yaml'
    envmodules:
        'scipy/1.4.1-python-3.7.7',
        'pysam/0.16.0.1-python-3.7.7'
    params:
        exe = config.get('monovar', {}).get('exe', '')
    shell:
        'python {params.exe} -i {input.pileup} -s {input.samples} -o {output} '
        '-m {threads} --CF_flag 0 --min_read_depth 1'


rule postprocess_monovar:
    input:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.monovar.vcf')
    output:
        os.path.join(base_dir, 'vcf_dir', 'vcf.{run}.monovar.final')
    envmodules:
        'numpy/1.18.1-python-3.7.7',
    params:
        dp = config.get('SNP_filter', {}).get('depth', 1),
        gq = config.get('SNP_filter', {}).get('quality', 0),
        singletons = config.get('SNP_filter', {}).get('singletons', False),
    script:
        f'{SCRIPT_DIR}/postprocess_vcf.py'


# -------------------------------- SCITE ---------------------------------------

def get_tree_inference_input(wildcards):
    if config.get('monovar', {}).get('run', False):
        vcf_in_file = 'vcf.{wildcards.run}.monovar.vcf.final' \
            .format(wildcards=wildcards)
    else:
        vcf_in_file = 'vcf.{wildcards.run}.final.gz'.format(wildcards=wildcards)
    return os.path.join(base_dir, 'vcf_dir', vcf_in_file)


rule run_scite:
    input:
        get_tree_inference_input
    output:
        os.path.join(base_dir, 'scite_dir', 'scite_tree.{run}_ml0.newick')
    resources:
        mem_mb = 6144,
        runtime = lambda wildcards, attempt: attempt * 480,
    envmodules:
        'numpy/1.18.1-python-3.7.7'
    params:
        steps = config['tree']['scite'].get('steps', 1E6),
        exe = config['tree']['scite'].get('exe', './infSCITE'),
    script:
        f'{SCRIPT_DIR}/run_scite.py'


# ------------------------------- CELLPHY --------------------------------------

rule run_cellphy:
    input:
        get_tree_inference_input
    output:
        os.path.join(base_dir, 'cellphy_dir',
            'cellphy_tree.{run}.Mapped.raxml.mutationMapTree')
    resources:
        mem_mb = 1024,
        runtime =  lambda wildcards, attempt: attempt * 300,
    threads: 1 if config['tree']['cellphy'].get('command', 'FAST') == 'FAST' \
        else 4
    params:
        prefix = lambda wildcards: os.sep.join([base_dir, 'cellphy_dir',
            'cellphy_tree.{wildcards.run}'.format(wildcards=wildcards)]),
        exe = config['tree']['cellphy'].get('exe', './cellphy.sh'),
        cmd = config['tree']['cellphy'].get('command', 'SEARCH'),
    shell:
        '{params.exe} {params.cmd} -o healthycell -r -t {threads} -z -l '
        '-p {params.prefix} {input} > /dev/null && '
        'rm -f {params.prefix}.raxml.startTree ' # {params.prefix}.raxml.bestModel
        '{params.prefix}.raxml.mlTrees'


# -------------------------------- PAUP ----------------------------------------

rule run_PAUP:
    input:
        os.path.join(base_dir, 'nxs_dir_{tree}', 'nxs.{run}.0.{model}')
    output:
        temp(os.path.join(base_dir, 'paup_dir_{tree}',
            'paup.{run}.0.{model}.PAUP.score'))
    resources:
        runtime = 60,
    params:
        prefix = lambda wildcards: os.sep.join([base_dir,
            'paup_dir_{wildcards.tree}'.format(wildcards=wildcards)]),
        paup_exe = config.get('paup', {}).get('exe', 'paup'),
    shell:
        'mkdir -p {params.prefix} && '
        '{params.paup_exe} -n {input} > '
        '{params.prefix}/paup.{wildcards.run}.{wildcards.model}.log && '
        'rm {params.prefix}/paup.{wildcards.run}.{wildcards.model}.log'


def get_paup_input(wildcards):
    if config.get('paup', {}).get('learn_tree', False):
        models = ['clock']
    else:
        models = MODELS

    in_files = []
    for model in models:
        for run in RUNS:
            in_files.append(os.path.join(base_dir,
                'paup_dir_{wildcards.tree}'.format(wildcards=wildcards),
                f'paup.{run}.0.{model}.PAUP.score'))
    return in_files


rule merge_paup_results:
    input:
        get_paup_input
    output:
        os.path.join(base_dir, 'paup_dir_{tree}', 'paup.summary.tsv')
    conda: 'envs/monovar.yaml'
    envmodules:
        'scipy/1.4.1-python-3.7.7',
    resources:
        mem_mb = 2048
    params:
        no_cells = config['cellcoal']['model']['no_cells'] + 1,
    script:
        f'{SCRIPT_DIR}/get_PAUP_LRT.py'


# ------------------------------- POISSON --------------------------------------

def get_poisson_input(wildcards):
    vcf_dir = os.path.join(base_dir, 'vcf_dir')
    if config.get('monovar', {}).get('run', False):
        return [os.path.join(vcf_dir, f'vcf.{i}.monovar.final') for i in RUNS]
    else:
        return [os.path.join(vcf_dir, f'vcf.{i}.final.gz') for i in RUNS]


rule run_poisson:
    input:
        get_poisson_input
    output:
        os.path.join(base_dir, 'poissonDisp.summary.tsv')
    conda:
        'envs/monovar.yaml'
    envmodules:
        'scipy/1.4.1-python-3.7.7',
    resources:
        mem_mb = 2048,
        runtime = 120,
    params:
        exclude = config.get('poisson', {}).get('exclude', ''),
        include = config.get('poisson', {}).get('include', ''),
    script:
        f'{SCRIPT_DIR}/get_poisson_LRT.py'


# --------------------------- POISSON TREE -------------------------------------


rule run_poisson_tree:
    input:
        unpack(get_nex_input)
    output:
        os.path.join(base_dir, 'poissonTree_{tree_weight}_{tree}',
            'poissonTree.{run}.LRT.txt')
    conda:
        ''
    envmodules:
        'biopython/1.77-python-3.7.7',
        'pandas/1.0.1-python-3.7.7',
        'scipy/1.4.1-python-3.7.7',
        'matplotlib/3.1.3-python-3.7.7'
    threads: 1
    resources:
        mem_mb = 1024,
        runtime = 30,
    params:
        exclude = config.get('poisson', {}).get('exclude', ''),
        include = config.get('poisson', {}).get('include', ''),
        paup_exe = config.get('paup', {}).get('exe', 'paup'),
    script:
        f'{SCRIPT_DIR}/get_poisson_tree_LRT.py'


rule merge_poisson_tree:
    input:
        expand(os.path.join(base_dir, 'poissonTree_{{tree_weight}}_{{tree}}',
            'poissonTree.{run}.LRT.txt'), run=RUNS)
    output:
        os.path.join(base_dir, 'poissonTree_{tree_weight}_{tree}',
            f'poissonTree.summary.tsv')
    conda:
        ''
    envmodules:
        'pandas/1.0.1-python-3.7.7',
        'matplotlib/3.1.3-python-3.7.7'
    resources:
        mem_mb = 2048,
    script:
        f'{SCRIPT_DIR}/merge_poisson_tree_LRT.py'