#!/usr/bin/env python3

import os
import sys
import yaml
from utils import *

MODELS = ['clock', 'noClock']
RUNS = [f'{i+1:04d}' for i in range(config['cellcoal']['no_rep'])]
TREES = [i for i,j in config['tree'].items() if j['run']]

scheduler = config.get('scheduler', None)

if isinstance(config['mrbayes']['ngen'], (int, float)):
    config['mrbayes']['ngen'] = [config['mrbayes']['ngen']]
out_dir, filter_dir = get_out_dir(config)


def get_final_files(wildcards):
    files = []
    if config['cellcoal'].get('output', {}).get('true_haplotypes', False):
        files += [os.path.join(out_dir, 'true_haplotypes_dir', f'true_vcf.{i}') 
            for i in RUNS]

    for tree in TREES:
        if config.get('mrbayes', {}).get('run', False):
            files.append(os.path.join(out_dir, filter_dir,
                'mrbayes_dir_{}'.format(tree), 'mrbayes.clock_test_summary.tsv'))
        if config.get('paup', {}).get('run', False):
            files.append(os.path.join(out_dir, filter_dir,
                'paup_dir_{}'.format(tree), 'paup.clock_test_summary.tsv'))
        if config.get('sieve', {}).get('run', False):
            files.append(os.path.join(out_dir, 'sieve_dir',
                'sieve_{}.clock_test_summary.tsv'.format(tree)))

    return files


rule all:
    input:
        get_final_files
        
            
rule create_cellcoal_config:
    output:
        cellcoal = 'cellcoal_parameters',
        snakemake ='snakemake_config.yaml',
    params:
        template = config['cellcoal'] \
            .get('parameter', 'cellcoal_parameters.template'),
    resources:
        mem_mb = 1024
    run:
        cc_config = get_cellcoal_config(config, params.template, out_dir)
        with open(output.cellcoal, 'w') as f:
            f.write(cc_config)
        with open(output.snakemake, 'w') as f_yaml:
            yaml.dump(config, f_yaml)


rule run_cellcoal:
    input:
        cellcoal = 'cellcoal_parameters',
        snakemake ='snakemake_config.yaml',
    output:
        expand(os.path.join(out_dir, 'vcf_dir', 'vcf.{run}'), run=RUNS),
        expand(os.path.join(out_dir, 'trees_dir', 'trees.{run}'), run=RUNS),
    resources:
        mem_mb = 32768 * (1 + config['cellcoal'].get('no_rep', 10) // 500)
    params:
        exe = config['cellcoal']['exe'],
    shell:
        'mkdir -p {out_dir} && {params.exe} -F{input} > {out_dir}/log && '
        'mv {input.cellcoal} {out_dir}/config_cellcoal && '
        'mv {input.snakemake} {out_dir}/config_snakemake'


rule postprocess_vcf:
    input:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}')
    output:
        os.path.join(out_dir, filter_dir, 'vcf_dir', 'vcf.{run}.final')
    envmodules:
        'numpy/1.18.1-python-3.7.7',
    params:
        dp = config.get('SNP_filter', {}).get('depth', 1),
        gq = config.get('SNP_filter', {}).get('quality', 0),
        singletons = '-fs' if config.get('SNP_filter', {}) \
            .get('singletons', False) else '',
    shell:
        'python utils.py {input} -f post -o {output} -gq {params.gq} '
        '-dp {params.dp} {params.singletons}'


rule get_true_GT:
    input:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}')
    output:
        os.path.join(out_dir, 'true_haplotypes_dir', 'true_vcf.{run}')
    resources:
        mem_mb = 4096
    run:
        haplotypes_to_vcf(input[0], output[0])


def get_nex_input(wildcards):
    if config.get('monovar', {}).get('run', False):
        vcf_in_file = 'vcf.{wildcards.run}.monovar.final' \
            .format(wildcards=wildcards)
    else:
        vcf_in_file = 'vcf.{wildcards.run}.final'.format(wildcards=wildcards)

    vcf = os.path.join(out_dir, filter_dir, 'vcf_dir', vcf_in_file)

    if wildcards.tree == 'cellphy':
        tree = os.path.join(out_dir, filter_dir, 'cellphy_dir',
            'cellphy_tree.{wildcards.run}.raxml.bestTree' \
                .format(wildcards=wildcards))
    elif wildcards.tree == 'scite':
        tree = os.path.join(out_dir, filter_dir, 'scite_dir',
            'scite_tree.{wildcards.run}_ml0.newick'.format(wildcards=wildcards))
    else:
        tree = os.path.join(out_dir, 'trees_dir', 'trees.{wildcards.run}' \
            .format(wildcards=wildcards))
        
    return {'tree': tree, 'vcf': vcf}


rule vcf_to_nex:
    input:
        unpack(get_nex_input)
    output:
        expand(os.path.join(out_dir, filter_dir, 'nxs_dir_{{tree}}',
                'nxs.{{run}}.{{steps}}.{model}'),
            model=MODELS)
    resources:
        mem_mb = 1024
    params:
        ss = config.get('mrbayes', {}).get('ss', False),
        paup_exe = config.get('paup', {}).get('exe', 'paup'),
    run:
        vcf_to_nex(input.vcf, output, wildcards.steps, ss_flag=params.ss,
            tree=input.tree, paup_exe=params.paup_exe)


# ------------------------------- MONOVAR --------------------------------------

rule vcf_to_mpileup:
    input:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}')
    output:
        pileup = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.mpileup'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleNames.txt'),
        s_types = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleTypes.txt')
    resources:
        mem_mb = 4096
    run:
        vcf_to_pileup(input[0], output.pileup, output.samples)


rule run_monovar:
    input:
        pileup = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.mpileup'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleNames.txt')
    output:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.monovar.vcf')
    threads: 2
    resources:
        mem_mb = 4096 if scheduler == 'lsf' else 2 * 4096
    conda: 'envs/monovar.yaml'
    envmodules:
        'scipy/1.4.1-python-3.7.7',
        'pysam/0.16.0.1-python-3.7.7'
    params:
        exe = config.get('monovar', {}).get('exe', '')
    shell:
        'python {params.exe} -i {input.pileup} -s {input.samples} -o {output} '
        '-m {threads} --CF_flag 0 --min_read_depth 1'


rule postprocess_monovar:
    input:
        os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.monovar.vcf')
    output:
        os.path.join(out_dir, filter_dir, 'vcf_dir', 'vcf.{run}.monovar.final')
    envmodules:
        'numpy/1.18.1-python-3.7.7',
    params:
        dp = config.get('SNP_filter', {}).get('depth', 1),
        gq = config.get('SNP_filter', {}).get('quality', 0),
        singletons = '-fs' if config.get('SNP_filter', {}) \
            .get('singletons', False) else '',
    shell:
        'python utils.py {input} -f post -o {output} -gq {params.gq} '
        '-dp {params.dp} {params.singletons}'


# -------------------------------- SCITE ---------------------------------------

def get_tree_inference_input(wildcards):
    if config.get('monovar', {}).get('run', False):
        vcf_in_file = 'vcf.{wildcards.run}.monovar.vcf.final' \
            .format(wildcards=wildcards)
    else:
        vcf_in_file = 'vcf.{wildcards.run}.final'.format(wildcards=wildcards)
    return os.path.join(out_dir, filter_dir, 'vcf_dir', vcf_in_file)


rule run_scite:
    input:
        get_tree_inference_input
    output:
        os.path.join(out_dir, filter_dir, 'scite_dir',
            'scite_tree.{run}_ml0.newick')
    resources:
        mem_mb = 4096
    envmodules:
        'numpy/1.18.1-python-3.7.7'
    params:
        steps = config['tree']['scite'].get('steps', 1E6),
        exe = config['tree']['scite'].get('exe', './infSCITE'),
    shell:
        'python utils.py {input} -f scite -e {params.exe} -s {params.steps} && '
        'rm -f {out_dir}/{filter_dir}/scite_dir/scite_tree.{wildcards.run}_*.gv'


# ------------------------------- CELLPHY --------------------------------------

rule run_cellphy:
    input:
        get_tree_inference_input
    output:
        os.path.join(out_dir, filter_dir, 'cellphy_dir',
            'cellphy_tree.{run}.raxml.bestTree')
    resources:
        mem_mb = 1024
    threads: 1 if config['tree']['cellphy'].get('command', 'FAST') == 'FAST' \
        else 4
    params:
        prefix = lambda wildcards: os.sep.join([out_dir, filter_dir,
            'cellphy_dir', 'cellphy_tree.{wildcards.run}' \
                .format(wildcards=wildcards)]), 
        exe = config['tree']['cellphy'].get('exe', './cellphy.sh'),
        cmd = config['tree']['cellphy'].get('command', 'FAST'),
    shell:
        '{params.exe} {params.cmd} -o healthycell -r -t {threads} -y -z '
        '-p {params.prefix} {input} > /dev/null && '
        'rm -f {params.prefix}.raxml.bestModel {params.prefix}.raxml.startTree '
        '{params.prefix}.raxml.mlTrees'
        

# ------------------------------- MRBAYES --------------------------------------

def get_mrbayes_hpc_runtime(steps):
    steps_int = int(steps)
    
    if steps_int <= 1E6:
        runtime = 240
    elif steps_int <= 5E6:
        runtime = 480
    elif steps_int <= 10E6:
        runtime = 1440
    elif steps_int <= 20E6:
        runtime = 1880
    elif steps_int <= 60E6:
        runtime = 3840
    elif steps_int <= 80E6:
        runtime = 4800
    else:
        runtime = 5760
        
    return runtime
        

rule run_mrbayes:
    input:
        os.path.join(out_dir, filter_dir, 'nxs_dir_{tree}',
            'nxs.{run}.{steps}.{model}')
    output:
        os.path.join(out_dir, filter_dir, 'mrbayes_dir_{tree}',
            'mrbayes.{run}.{steps}.{model}.lstat')
    conda: 'envs/mrbayes.yaml'
    envmodules:
        'gcc/6.4.0',
        'openmpi/2.1.1',
        'mrbayes/3.2.7'
    threads: 4
    resources:
        mem_mb = 4096 if scheduler == 'lsf' else 3 * 4096,
        runtime = lambda wildcards: get_mrbayes_hpc_runtime(wildcards.steps)
    params:
        model_str = lambda wildcards: 
            '{wildcards.run}.{wildcards.steps}.{wildcards.model}' \
                .format(wildcards=wildcards), 
        mb_exe = config['mrbayes']['exe'] if not scheduler else 'mpirun mb',
    shell:
        'cd {out_dir}/{filter_dir} && mkdir -p mrbayes_dir_{wildcards.tree} && '
        '{params.mb_exe} nxs_dir_{wildcards.etree}/nxs.{params.model_str} > '
        'mrbayes_dir_{wildcards.tree}/mrbayes.{params.model_str}.log && '
        'rm -f nxs_dir_{wildcards.tree}/nxs.{params.model_str}.* '
        'mrbayes_dir_{wildcards.tree}/mrbayes.{params.model_str}.pstat'


rule merge_mrbayes_results:
    input:
        expand(os.path.join(out_dir, filter_dir, 'mrbayes_dir_{{tree}}',
                'mrbayes.{run}.{steps}.{model}.lstat'),
            run=RUNS, steps=config['mrbayes']['ngen'], model=MODELS)
    output:
        os.path.join(out_dir, filter_dir, 'mrbayes_dir_{tree}',
            'mrbayes.clock_test_summary.tsv')
    resources:
        mem_mb=2048
    params:
        ss = '-ss' if config.get('mrbayes', {}).get('ss', False) else '',
    shell:
        'python utils.py {input} -f bayes -o {output} {params.ss}'


# -------------------------------- PAUP ----------------------------------------

rule run_PAUP:
    input:
        os.path.join(out_dir, filter_dir, 'nxs_dir_{tree}', 
            'nxs.{run}.0.{model}')
    output:
        os.path.join(out_dir, filter_dir, 'paup_dir_{tree}',
            'paup.{run}.0.{model}.PAUP.score')
    params:
        prefix = lambda wildcards: os.sep.join([out_dir, filter_dir,
            'paup_dir_{wildcards.tree}'.format(wildcards=wildcards)]), 
        paup_exe = config.get('paup', {}).get('exe', 'paup'),
    shell:
        'mkdir -p {params.prefix} && '
        '{params.paup_exe} -n {input} > '
        '{params.prefix}/paup.{wildcards.run}.{wildcards.model}.log'


def get_paup_input(wildcards):
    if config.get('paup', {}).get('learn_tree', False):
        models = ['clock']
    else:
        models = MODELS

    in_files = []
    for model in models:
        for run in RUNS:
            in_files.append(os.path.join(out_dir, filter_dir,
                'paup_dir_{wildcards.tree}'.format(wildcards=wildcards),
                'paup.{}.0.{}.PAUP.score'.format(run, model)))
    return in_files


rule prepare_paup_merging:
    input:
        get_paup_input
    output:
        os.path.join(out_dir, filter_dir, 'paup_dir_{tree}', 'masterfile.txt')
    run:
        with open(output[0], 'w') as f_out:
            for in_file in input:
                f_out.write(in_file + '\n')


rule merge_paup_results:
    input:
        os.path.join(out_dir, filter_dir, 'paup_dir_{tree}', 'masterfile.txt')
    output:
        os.path.join(out_dir, filter_dir, 'paup_dir_{tree}',
            'paup.clock_test_summary.tsv')
    conda: 'envs/monovar.yaml'
    envmodules:
        'scipy/1.4.1-python-3.7.7',
    resources:
        mem_mb = 2048
    params:
        no_cells = config['cellcoal']['model']['no_cells'],
    shell:
        'python utils.py {input} -f LRT -o {output} -nc {params.no_cells} && '
        'tail -n 1 {output}'


# -------------------------------- SIEVE ---------------------------------------

rule run_sciphi:
    input:
        pileup = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.mpileup'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleTypes.txt')
    output:
        os.path.join(out_dir, 'sieve_dir', 'sciphi.{run}', 'best_index',
            'readCounts.tsv')
    resources:
        mem_mb=4048
    envmodules:
        'gcccore/6.4.0',
        'boost/1.73.0-python-3.7.7',
        'seqan/2.4.0',
        'dlib/19.16',
        'zlib/1.2.11'
    params:
        sciphi = config['sieve']['sciphi_exe'],
    shell:
        '{params.sciphi} --cwm 2 --slt on --af on --in {input.samples} '
        '-o {out_dir}/sieve_dir/sciphi.{wildcards.run} {input.pileup}'


rule run_sieve_data_collector:
    input:
        read_counts = os.path.join(out_dir, 'sieve_dir', 'sciphi.{run}',
            'best_index', 'readCounts.tsv'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleTypes.txt')
    output:
        os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'sieve_template_updated.xml')
    params:
        beast = config['sieve']['beast_bin'],
        xml = config['sieve']['xml']
    shell:
        '{params.beast}/applauncher DataCollectorLauncher -prefix '
        '{out_dir}/sieve_dir/xml.{wildcards.run}/ -cell {input.samples} -sciphi '
        '-data {input.read_counts} -template {params.xml}'


def get_nex_input(wildcards):
    if wildcards.tree == 'scite':
        return os.path.join(out_dir, filter_dir, 'scite_dir',
            'scite_tree.{run}_ml0.newick'.format(wildcards=wildcards))
    elif wildcards.tree == 'cellphy':
        return os.path.join(out_dir, filter_dir, 'cellphy_dir',
            'cellphy_tree.{wildcards.run}.raxml.bestTree.rooted' \
                .format(wildcards=wildcards))
    else:
        return os.path.join(out_dir, 'trees_dir',
            'trees.{wildcards.run}'.format(wildcards=wildcards))


rule get_sieve_tree:
    input:
        get_nex_input
    output:
        os.path.join(out_dir, 'sieve_dir', 'sieve_tree_{tree}.{run}')   
    params:
        cells = config['cellcoal']['model']['no_cells']
    run:
        get_sieve_tree(input[0], output[0], params.cells)


rule get_sieve_final_xml:
    input:
        xml = os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'sieve_template_updated.xml'),
        tree = os.path.join(out_dir, 'sieve_dir', 'sieve_tree_{tree}.{run}'),
        samples = os.path.join(out_dir, 'vcf_dir', 'vcf.{run}.SampleTypes.txt')
    output:
        os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'sieve_{model}_{tree}.xml')
    params:
        steps = config['sieve']['steps']    
    run:
        get_sieve_xml(input.xml, input.tree, input.samples, wildcards.model,
            params.steps, output[0])


rule run_NS_converter:
    input:
        os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'sieve_{model}_{tree}.xml')
    output:
        os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'NS_sieve_{model}_{tree}.xml')
    params:
        beast = config['sieve']['beast_bin'],
    shell:
        '{params.beast}/applauncher MCMC2NS -xml {input} -output {output} '
        '-particleCount 1'


rule run_sieve:
    input:
        os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'NS_sieve_{model}_{tree}.xml')
    output:
        os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
            'sieve_{model}_{tree}_final')
    threads: 2
    params:
        beast = config['sieve']['beast_bin'],
    shell:
        '{params.beast}/beast -threads {threads} -overwrite -prefix '
        '{out_dir}/sieve_dir/xml.{wildcards.run}/'
        'beast.{wildcards.model}.{wildcards.tree} {input}'


rule merge_sieve_results:
    input:
        expand(os.path.join(out_dir, 'sieve_dir', 'xml.{run}',
                'sieve_{model}_{{tree}}_final'),
            run=RUNS, model=MODELS)
    output:
        os.path.join(out_dir, 'sieve_dir',
            'sieve_{tree}.clock_test_summary.tsv')
    resources:
        mem_mb = 2048
    shell:
        'python utils.py {input} -f sieve -o {output}'